I'm coding a python videogame recommendation system.
I load user-item interaction matrix from csv file.
This code creates sparse matrix from user-item interaction matrix.
train_sparse = sparse.csr_matrix(train.values)

# Add X users to Test so that the number of rows in Train match Test
N = train.shape[0]                      # Rows in Train set
n, m = test.shape                       # Rows & columns in Test set
z = np.zeros([(N - n), m])              # Create the necessary rows of zeros with m columns


test = np.vstack((test, z))             # Vertically stack Test on top of the blank users
test_sparse = sparse.csr_matrix(test)   # Convert back to sparse

print(train_sparse.get_shape())
Then I use this function to train a LightFM matrix factorization model.
def run_model(interactions, n_components=30, loss="warp", epoch=30, n_jobs=4):
    """
    Runs matrix-factorization model using LightFM
    Arguments:
        interactions = DataFrame containing user-item interactions
        n_components = number of desired embeddings to create to define item and user
        loss = loss function other options are logistic, brp
        epoch = number of epochs to run
        n_jobs = number of cores used for execution
    Returns:
        Model = Trained model
    """
    x = sparse.csr_matrix(interactions.values)
    model = LightFM(no_components=n_components, loss=loss)
    model.fit(x, epochs=epoch, num_threads=n_jobs)
    return model
I also use this code to evaluate model.
train_precision = precision_at_k(mf_model_warp, train_sparse, k=k).mean()
test_precision = precision_at_k(mf_model_warp, test_sparse, k=k).mean()
print("Precision: train %.2f, test %.2f." % (train_precision, test_precision))

train_recall = recall_at_k(mf_model_warp, train_sparse, k=k).mean()
test_recall = recall_at_k(mf_model_warp, test_sparse, k=k).mean()
print("Recall: train %.2f, test %.2f." % (train_recall, test_recall))

# Get AUC
train_auc = auc_score(mf_model_warp, train_sparse).mean()
test_auc = auc_score(mf_model_warp, test_sparse).mean()
print("AUC: train %.2f, test %.2f." % (train_auc, test_auc))
Write me some code that makes a function out of evaluation code, and then make a grid search to find optimal parameters for this model. 